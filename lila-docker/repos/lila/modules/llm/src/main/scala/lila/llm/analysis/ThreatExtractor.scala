package lila.llm.analysis

import lila.llm.model._
import lila.llm.model.strategic._
import chess.Color

/**
 * Extracts Deep Causality (the "Why") from counterfactual variations.
 * Identifies the specific tactical or strategic threat allowed by a sub-optimal move.
 */
object ThreatExtractor {

  case class CausalThreat(
      concept: String,       // e.g., "Mating Attack", "Material Loss", "Positional Collapse"
      severity: Int,         // Severity score to pick the most critical threat
      narrative: String,     // e.g., "allows White to execute a deadly fork on c7"
      motifs: List[Motif]    // The underlying motifs that prove the threat
  )

  /**
   * Extracts the causal threat by analyzing the opponent's replies in the user's blunder PV.
   */
  def extractCounterfactualCausality(
      fen: String,
      playerColor: Color,
      userLine: VariationLine,
      bestLine: VariationLine
  ): Option[CausalThreat] = {
    // 1. Play out the user's line to extract all motifs
    // userLine.moves starts with the user's blunder, e.g. [b6a4, f4f5, ...]
    if (userLine.moves.size < 2) return None

    val userMotifs = MoveAnalyzer.tokenizePv(fen, userLine.moves)
    
    // We want to find the punishing motifs generated by the OPPONENT.
    // The user's move is ply 0 (even if the game ply is odd, relative to the variation it's ply 0).
    // Opponent plays on ply 1, 3, 5, etc.
    // Wait, MoveAnalyzer.tokenizePv assigns 'ply' based on the variation index (0 to N-1).
    // Let's filter motifs that belong to the opponent's turns (plyIndex % 2 == 1).
    // EXCEPT for structural damage (DoubledPawns, IsolatedPawn) which often materializes 
    // on the player's turn (plyIndex % 2 == 0) after a recapture.
    val opponentMotifs = userMotifs.filter { m => 
      m.plyIndex % 2 == 1 || m.isInstanceOf[Motif.DoubledPawns] || m.isInstanceOf[Motif.IsolatedPawn]
    }

    // 2. Classify the severity of opponent motifs
    // We map motifs to (Concept, Severity, Narrative Base)
    val criticalThreats = opponentMotifs.flatMap(classifyMotif(_, playerColor))

    if (criticalThreats.isEmpty) {
      // Fallback: Check if there's a huge evaluation drop without clear tactical motifs
      val evalDrop = PerspectiveMath.cpLossForMover(playerColor, bestLine.effectiveScore, userLine.effectiveScore)
      if (evalDrop > 200) {
        Some(CausalThreat("Positional Collapse", 1, "concedes a devastating positional advantage", Nil))
      } else {
        None
      }
    } else {
      // Group by concept and sort by severity
      val topThreat = criticalThreats.sortBy(-_._2).head
      Some(CausalThreat(
        concept = topThreat._1,
        severity = topThreat._2,
        narrative = topThreat._3,
        motifs = opponentMotifs
      ))
    }
  }

  /**
   * Identifies the primary threat concept from an opponent's line (e.g., a Null-Move threat line).
   */
  def extractThreatConcept(
      fen: String,
      playerColor: Color,
      threatLine: VariationLine
  ): Option[CausalThreat] = {
    // The threatLine is from the opponent's POV (starts with their punishing move).
    // So all motifs in this line are relevant threats.
    val motifs = MoveAnalyzer.tokenizePv(fen, threatLine.moves)
    val criticalThreats = motifs.flatMap(classifyMotif(_, playerColor))

    if (criticalThreats.isEmpty) {
      if (threatLine.scoreCp.abs > 200) {
        Some(CausalThreat("Positional Collapse", 1, "concedes a positional advantage", Nil))
      } else None
    } else {
      val topThreat = criticalThreats.sortBy(-_._2).head
      Some(CausalThreat(
        concept = topThreat._1,
        severity = topThreat._2,
        narrative = topThreat._3,
        motifs = motifs
      ))
    }
  }

  def classifyMotif(motif: Motif, playerColor: Color): Option[(String, Int, String)] = {
    // Return (Concept, SeverityScore, Narrative Fragment)
    val oppColor = !playerColor
    val oppColorStr = oppColor.name.capitalize
    motif match {
      case _: Motif.MateNet => 
        Some(("Mating Attack", 100, s"allows $oppColorStr to weave a mating net"))
      case m: Motif.Check if m.checkType == Motif.CheckType.Mate || m.checkType == Motif.CheckType.Smothered =>
        Some(("Checkmate", 100, s"allows a forced checkmate"))
      case _: Motif.SmotheredMate =>
        Some(("Checkmate", 100, s"allows a forced smothered mate"))
      case _: Motif.BackRankMate =>
        Some(("Checkmate", 100, s"allows a back-rank mate"))
      case _: Motif.PawnPromotion =>
        Some(("Promotion", 95, s"allows the opponent to promote a pawn"))
      case m: Motif.Fork =>
        Some(("Material Loss", 85, s"allows a devastating fork on ${m.targets.mkString(" and ")}"))
      case m: Motif.TrappedPiece if m.isValuableTrap =>
        Some(("Material Loss", 85, s"allows the ${m.trappedRole} to be trapped"))
      case m: Motif.Skewer =>
        Some(("Tactical Exploitation", 80, s"allows a fatal skewer against the ${m.frontPiece}"))
      case _: Motif.DoubleCheck =>
        Some(("Mating Attack", 80, s"walks into a lethal double check"))
      case m: Motif.DiscoveredAttack =>
        Some(("Tactical Discovery", 75, s"walks into a dangerous discovered attack by the ${m.attackingPiece}"))
      case m: Motif.Pin if m.isAbsolutePin =>
        Some(("Tactical Binding", 75, s"allows a crippling absolute pin against the ${m.pinnedPiece}"))
      case m: Motif.Pin =>
        Some(("Tactical Binding", 70, s"allows an uncomfortable pin against the ${m.pinnedPiece}"))
      case m: Motif.RemovingTheDefender =>
        Some(("Defensive Collapse", 70, s"allows the removal of the critical ${m.victim} defending the ${m.protectedTarget}"))
      case m: Motif.Deflection =>
        Some(("Defensive Collapse", 70, s"forces the ${m.piece} away from its defensive duties"))
      case m: Motif.Decoy =>
        Some(("Tactical Exploitation", 65, s"allows a decoy sequence targeting the ${m.piece}"))
      case m: Motif.Overloading =>
        Some(("Defensive Collapse", 65, s"overloads the ${m.overloadedPiece}, causing defenses to crumble"))
      case _: Motif.Interference =>
        Some(("Tactical Exploitation", 65, s"allows interference against the coordinated defense"))
      case _: Motif.PassedPawnPush =>
        Some(("Promotion Threat", 70, s"allows the opponent's passed pawn to advance dangerously"))
      
      // -- Positional and Structural Dominance --
      case m: Motif.Outpost =>
        Some(("Positional Dominance", 60, s"allows the ${m.piece} to establish a dominating outpost on ${m.square}"))
      case m: Motif.PassedPawn if m.color == oppColor =>
        Some(("Structural Threat", 60, s"allows the creation of a dangerous passed pawn on the ${m.file} file"))
      case m: Motif.DoubledPawns if m.color == playerColor =>
        Some(("Structural Ruin", 55, s"ruins the pawn structure by creating doubled pawns on the ${m.file} file"))
      case m: Motif.IsolatedPawn if m.color == playerColor =>
        Some(("Structural Ruin", 55, s"accepts a permanent weakness with an isolated pawn on the ${m.file} file"))
      case m: Motif.OpenFileControl =>
        Some(("Positional Dominance", 55, s"concedes total control of the ${m.file} file"))
      case _: Motif.SeventhRankInvasion =>
        Some(("Positional Dominance", 65, s"allows a devastating invasion on the 7th rank"))
      case m: Motif.SpaceAdvantage if m.pawnDelta >= 2 =>
        Some(("Positional Dominance", 50, s"concedes a massive space advantage in the center"))
      case m: Motif.KingCutOff =>
        Some(("King Safety Compromised", 65, s"allows the king to be dangerously cut off along the ${if (m.axis == "Rank") s"${m.coordinate}th rank" else s"${m.coordinate} file"}"))
      case _: Motif.WeakBackRank =>
        Some(("King Safety Compromised", 60, s"leaves the back rank critically weak"))
        
      case m: Motif.Capture if m.captureType == Motif.CaptureType.Winning =>
        Some(("Material Loss", 85, s"blunders the ${m.captured}"))
      case m: Motif.XRay =>
        Some(("Tactical Exploitation", 65, s"allows an X-Ray attack through the ${m.piece}"))
      // Add more specific tactical/positional mappings here to ensure diverse detection
      case _ => None
    }
  }
}
